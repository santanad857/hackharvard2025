# backend/tune_loss.py
from pathlib import Path
import argparse
import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score, average_precision_score, precision_recall_curve, f1_score
from sklearn.model_selection import GroupShuffleSplit

def main():
    ap = argparse.ArgumentParser(description="Fit weights on z-scored features; write weights.py with thresholds.")
    ap.add_argument("--dataset", default="backend/dataset.csv")
    ap.add_argument("--scaler-cache", default="backend/scaler_values_cache.npz")
    ap.add_argument("--out-weights", default="backend/weights.py")
    ap.add_argument("--val-size", type=float, default=0.25)
    ap.add_argument("--seed", type=int, default=42)
    ap.add_argument("--alpha", type=float, default=0.3, help="EMA alpha for video-level scoring")
    ap.add_argument("--percentile", type=float, default=95.0, help="Percentile over EMA for video-level")
    args = ap.parse_args()

    df = pd.read_csv(args.dataset)
    cols = ["sharp_var","high_ratio","edge_glitch","block_energy","chroma_mismatch"]
    X_raw = df[cols].values.astype(np.float32)
    y     = df["label"].values.astype(np.int32)
    groups= df["video"].values

    d = np.load(args.scaler_cache)
    mean, scale = d["mean"].astype(np.float32), d["scale"].astype(np.float32)
    if mean.shape[0] != X_raw.shape[1]:
        raise SystemExit(f"Scaler dim {mean.shape[0]} != feature dim {X_raw.shape[1]} â€” refit scaler on REAL.")
    X = (X_raw - mean) / (scale + 1e-8)

    splitter = GroupShuffleSplit(n_splits=1, test_size=args.val_size, random_state=args.seed)
    (tr, va), = splitter.split(X, y, groups)
    Xtr, ytr, gtr = X[tr], y[tr], groups[tr]
    Xva, yva, gva = X[va], y[va], groups[va]

    clf = LogisticRegression(penalty="l2", C=1.0, solver="liblinear", class_weight="balanced", random_state=args.seed)
    clf.fit(Xtr, ytr)

    pva = clf.predict_proba(Xva)[:,1]
    auc = roc_auc_score(yva, pva)
    ap  = average_precision_score(yva, pva)
    prec, rec, thr = precision_recall_curve(yva, pva)
    f1s = 2*prec*rec/(prec+rec+1e-8)
    i = np.nanargmax(f1s)
    THRESH = 0.5 if i >= len(thr) else float(thr[i])
    F1 = f1_score(yva, (pva >= THRESH).astype(int))

    # Video-level threshold using EMA+p95 over validation split
    def ema(xs, a):
        out=[]; prev=None
        for x in xs:
            prev = x if prev is None else a*x + (1-a)*prev
            out.append(prev)
        return np.array(out, np.float32)

    # group pva by video, compute EMA then percentile
    vid_to_probs = {}
    for prob, vid in zip(pva, gva):
        vid_to_probs.setdefault(vid, []).append(float(prob))

    video_scores, video_labels = [], []
    for vid, probs in vid_to_probs.items():
        arr = np.array(probs, np.float32)
        e = ema(arr, args.alpha)
        score = float(np.percentile(e, args.percentile))
        video_scores.append(score)
        # majority label (frames share the same label)
        lab = int(np.round(np.mean(yva[[k for k,(v2) in enumerate(gva) if v2==vid]])))
        video_labels.append(lab)

    video_scores = np.array(video_scores, np.float32)
    video_labels = np.array(video_labels, np.int32)
    pv_prec, pv_rec, pv_thr = precision_recall_curve(video_labels, video_scores)
    pv_f1s = 2*pv_prec*pv_rec/(pv_prec+pv_rec+1e-8)
    j = np.nanargmax(pv_f1s)
    THRESH_VIDEO = 0.5 if j >= len(pv_thr) else float(pv_thr[j])
    F1v = f1_score(video_labels, (video_scores >= THRESH_VIDEO).astype(int))

    W = clf.coef_.ravel().astype(np.float32)
    B = float(clf.intercept_[0])

    print(f"[val] frame-level:  ROC-AUC={auc:.3f}  AP={ap:.3f}  F1@{THRESH:.3f}={F1:.3f}")
    print(f"[val] video-level:  F1@{THRESH_VIDEO:.3f}={F1v:.3f}  (EMA a={args.alpha}, p={args.percentile})")
    print(f"[weights] W={W.tolist()}  B={B:.4f}")

    out = Path(args.out_weights)
    out.write_text(
f"""# Auto-generated by tune_loss.py
import numpy as np
W = np.array({W.tolist()}, dtype=np.float32)
B = {B:.8f}
THRESH = {THRESH:.6f}        # frame-level threshold on sigmoid
THRESH_VIDEO = {THRESH_VIDEO:.6f}  # video-level threshold (EMA+p{int(args.percentile)})
"""
    )
    print(f"[done] wrote {out.resolve()}")

if __name__ == "__main__":
    main()
